#!/usr/bin/env node

import fs from 'fs'
import path from 'path'
import crypto from 'crypto'
import { fileURLToPath } from 'url'

// Ëé∑ÂèñÂΩìÂâçÊñá‰ª∂ÁöÑÁõÆÂΩïË∑ØÂæÑÔºàES Ê®°Âùó‰∏≠ÁöÑ __dirname Êõø‰ª£ÊñπÊ°àÔºâ
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

// ÈÖçÁΩÆ
const config = {
  // ‰ªé package.json ËØªÂèñÁâàÊú¨
  version: process.env.npm_package_version || '0.1.0',
  // ÂèëÂ∏ÉÊó∂Èó¥
  pub_date: new Date().toISOString(),
  // Êõ¥Êñ∞ËØ¥Êòé
  notes: process.env.RELEASE_NOTES || '‰øÆÂ§çÁºñËæëÂô®‰ª£Á†ÅÂùó‰∏ªÈ¢òÂàáÊç¢ÈóÆÈ¢ò',
  // GitHub ‰ªìÂ∫ì‰ø°ÊÅØ
  repo: process.env.GITHUB_REPOSITORY || 'o0x1024/mytips',
  // ÊòØÂê¶‰∏∫È¢ÑÂèëÂ∏ÉÁâàÊú¨
  prerelease: process.env.PRERELEASE === 'true'
}

// Ê£ÄÊü•ÊòØÂê¶‰∏∫ debug ÊûÑÂª∫
const isDebug = process.argv.includes('--debug');
if (isDebug) {
  console.log('üí° Ê£ÄÊµãÂà∞ Debug ÊûÑÂª∫Ê®°ÂºèÔºåÂ∞ÜË∑≥ËøáÁ≠æÂêç„ÄÇ');
}

// ÊîØÊåÅÁöÑÂπ≥Âè∞
const platforms = {
  'darwin-x86_64': {
    signature: '',
    url: `https://github.com/${config.repo}/releases/download/v${config.version}/mytips-${config.version}-x86_64.app.tar.gz`
  },
  'darwin-aarch64': {
    signature: '',
    url: `https://github.com/${config.repo}/releases/download/v${config.version}/mytips-${config.version}-aarch64.app.tar.gz`
  },
  'linux-x86_64': {
    signature: '',
    url: `https://github.com/${config.repo}/releases/download/v${config.version}/mytips-${config.version}-amd64.AppImage.tar.gz`
  },
  'windows-x86_64': {
    signature: '',
    url: `https://github.com/${config.repo}/releases/download/v${config.version}/mytips-${config.version}-x64-setup.nsis.zip`
  }
}

// ËØªÂèñÁ≠æÂêçÊñá‰ª∂
function readSignature(platform) {
  let sigPath
  let targetDir = ''

  // Ê†πÊçÆÂπ≥Âè∞Á°ÆÂÆö Rust ÁõÆÊ†á‰∏âÂÖÉÁªÑ
  switch (platform) {
    case 'darwin-x86_64':
      targetDir = 'x86_64-apple-darwin';
      break;
    case 'darwin-aarch64':
      targetDir = 'aarch64-apple-darwin';
      break;
    case 'linux-x86_64':
      targetDir = 'x86_64-unknown-linux-gnu';
      break;
    case 'windows-x86_64':
      targetDir = 'x86_64-pc-windows-msvc';
      break;
  }

  // ÂÆö‰πâÂéüÁîüÂíå‰∫§ÂèâÁºñËØëÁöÑË∑ØÂæÑ
  const crossCompilePath = targetDir ? path.join(__dirname, '..', 'src-tauri', 'target', targetDir, 'release', 'bundle') : null;
  const nativePath = path.join(__dirname, '..', 'src-tauri', 'target', 'release', 'bundle');

  // ‰ºòÂÖà‰ΩøÁî®‰∫§ÂèâÁºñËØëË∑ØÂæÑÔºàÂú®CIÁéØÂ¢É‰∏≠Êõ¥Â∏∏ËßÅÔºâÔºåÂê¶ÂàôÂõûÈÄÄÂà∞ÂéüÁîüË∑ØÂæÑ
  const bundlePath = crossCompilePath && fs.existsSync(crossCompilePath) ? crossCompilePath : nativePath;

  // Ê†πÊçÆÂπ≥Âè∞Á°ÆÂÆöÁ≠æÂêçÊñá‰ª∂ÁöÑÂÖ∑‰ΩìË∑ØÂæÑ
  const version = config.version;
  
  const findSigFile = (dir, extension) => {
    if (!fs.existsSync(dir)) return null;
    const files = fs.readdirSync(dir);
    const sigFile = files.find(f => f.endsWith(extension));
    return sigFile ? path.join(dir, sigFile) : null;
  };

  if (platform.startsWith('darwin-')) {
    // Tauri ÈÄöÂ∏∏‰∏ç‰ºöÂú® macos ÁöÑ .app ÂåÖÂêç‰∏≠Âä†ÂÖ•ÁâàÊú¨Âè∑
    sigPath = path.join(bundlePath, 'macos', `mytips.app.tar.gz.sig`);
  } else if (platform === 'linux-x86_64') {
    sigPath = path.join(bundlePath, 'appimage', `mytips_${version}_amd64.AppImage.tar.gz.sig`);
  } else if (platform === 'windows-x86_64') {
    // Âä®ÊÄÅÊü•Êâæ NSIS Êàñ MSI Á≠æÂêçÊñá‰ª∂Ôºå‰ºòÂÖà‰ΩøÁî® NSIS
    const nsisSigPath = findSigFile(path.join(bundlePath, 'nsis'), '.nsis.zip.sig');
    const msiSigPath = findSigFile(path.join(bundlePath, 'msi'), '.msi.zip.sig');
    sigPath = nsisSigPath || msiSigPath;
  } else {
    console.warn(`Ë≠¶Âëä: Êú™Áü•Âπ≥Âè∞ ${platform}`);
    return null;
  }
  
  try {
    if (sigPath && fs.existsSync(sigPath)) {
      return fs.readFileSync(sigPath, 'utf8').trim()
    } else {
      console.warn(`Ë≠¶Âëä: Á≠æÂêçÊñá‰ª∂‰∏çÂ≠òÂú®‰∫éÈ¢ÑÊúüË∑ØÂæÑ: ${sigPath || 'Êú™ÊâæÂà∞'}`)
      return null
    }
  } catch (error) {
    console.error(`ËØªÂèñÁ≠æÂêçÊñá‰ª∂Â§±Ë¥• ${sigPath}:`, error.message)
    return null
  }
}

// ÁîüÊàêÁªü‰∏ÄÊ∏ÖÂçï
function generateUnifiedManifest(outputDir) {
  const manifest = {
    version: config.version,
    notes: config.notes,
    pub_date: config.pub_date,
    platforms: {}
  }
  
  Object.keys(platforms).forEach(platform => {
    const signature = readSignature(platform)
    const platformData = {
      url: platforms[platform].url
    }
    
    // Âè™ÊúâÂΩìÁ≠æÂêçÂ≠òÂú®‰∏î‰∏çÊòØ debug ÊûÑÂª∫Êó∂ÊâçÊ∑ªÂä†Á≠æÂêçÂ≠óÊÆµ
    if (signature && !isDebug) {
      platformData.signature = signature
    }
    
    manifest.platforms[platform] = platformData
  })
  
  const manifestPath = path.join(outputDir, 'latest.json')
  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2))
  console.log(`‚úÖ Â∑≤ÁîüÊàêÁªü‰∏ÄÊ∏ÖÂçï: ${manifestPath}`)
}

// ‰∏ªÂáΩÊï∞
function main() {
  const outputDir = path.join(__dirname, '..', 'dist', 'update-manifests')
  
  // Á°Æ‰øùËæìÂá∫ÁõÆÂΩïÂ≠òÂú®
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  console.log('Ê≠£Âú®ÁîüÊàêÊõ¥Êñ∞Ê∏ÖÂçï...')
  console.log(`ÁâàÊú¨: ${config.version}`)
  console.log(`ÂèëÂ∏ÉÊó∂Èó¥: ${config.pub_date}`)

  try {
    // ÁîüÊàêÁªü‰∏ÄÊ∏ÖÂçïÔºàÂåÖÂê´ÊâÄÊúâÂπ≥Âè∞Ôºâ
    generateUnifiedManifest(outputDir)

    // ÁîüÊàêÂêÑÂπ≥Âè∞ÁâπÂÆöÊ∏ÖÂçï
    Object.keys(platforms).forEach(platform => {
      const signature = readSignature(platform)
      const platformManifest = {
        version: config.version,
        notes: config.notes,
        pub_date: config.pub_date,
        url: platforms[platform].url
      }
      
      // Âè™ÊúâÂΩìÁ≠æÂêçÂ≠òÂú®‰∏î‰∏çÊòØ debug ÊûÑÂª∫Êó∂ÊâçÊ∑ªÂä†Á≠æÂêçÂ≠óÊÆµ
      if (signature && !isDebug) {
        platformManifest.signature = signature
      }
      
      const platformPath = path.join(outputDir, `${platform}.json`)
      fs.writeFileSync(platformPath, JSON.stringify(platformManifest, null, 2))
      console.log(`‚úÖ Â∑≤ÁîüÊàê ${platform} Ê∏ÖÂçï: ${platformPath}`)
    })

    // ÁîüÊàêÈÉ®ÁΩ≤ËÑöÊú¨
    generateDeployScript(outputDir)

    console.log('\nüéâ Êõ¥Êñ∞Ê∏ÖÂçïÁîüÊàêÂÆåÊàê!')
    console.log('\nüìù ‰∏ã‰∏ÄÊ≠•Êìç‰Ωú:')
    console.log('1. ÊûÑÂª∫Â∫îÁî®: yarn tauri build')
    console.log('2. ÂàõÂª∫ GitHub Release')
    console.log('3. ‰∏ä‰º†ÊûÑÂª∫‰∫ßÁâ©Âà∞ Release')
    console.log('4. ‰∏ä‰º†Êõ¥Êñ∞Ê∏ÖÂçïÂà∞ Release')

  } catch (error) {
    console.error('‚ùå ÁîüÊàêÊõ¥Êñ∞Ê∏ÖÂçïÂ§±Ë¥•:', error.message)
    process.exit(1)
  }
}

// ÁîüÊàêÈÉ®ÁΩ≤ËÑöÊú¨
function generateDeployScript(outputDir) {
  const projectRoot = path.join(__dirname, '..', '..');

  const findBundleDir = (platform) => {
    const BUNDLE_DIR = path.join(projectRoot, 'src-tauri', 'target', 'release', 'bundle');
    let crossBundleDir = '';
    switch (platform) {
      case 'darwin-aarch64':
        crossBundleDir = path.join(projectRoot, 'src-tauri', 'target', 'aarch64-apple-darwin', 'release', 'bundle');
        break;
      case 'darwin-x86_64':
        crossBundleDir = path.join(projectRoot, 'src-tauri', 'target', 'x86_64-apple-darwin', 'release', 'bundle');
        break;
      case 'windows-x86_64':
        crossBundleDir = path.join(projectRoot, 'src-tauri', 'target', 'x86_64-pc-windows-msvc', 'release', 'bundle');
        break;
      case 'linux-x86_64':
        crossBundleDir = path.join(projectRoot, 'src-tauri', 'target', 'x86_64-unknown-linux-gnu', 'release', 'bundle');
        break;
    }
    return crossBundleDir && fs.existsSync(crossBundleDir) ? crossBundleDir : BUNDLE_DIR;
  };

  const getAssetPaths = (platform) => {
    const bundleDir = findBundleDir(platform);
    const assets = [];
    
    const findFiles = (dir, pattern) => {
      if (!fs.existsSync(dir)) return [];
      return fs.readdirSync(dir)
        .filter(f => f.match(pattern))
        .map(f => path.relative(projectRoot, path.join(dir, f)));
    };
    
    switch (platform) {
      case 'darwin-aarch64':
      case 'darwin-x86_64':
        assets.push(...findFiles(path.join(bundleDir, 'macos'), /^mytips\.app\.tar\.gz(\.sig)?$/));
        assets.push(...findFiles(path.join(bundleDir, 'dmg'), /^mytips_.*\.dmg$/));
        break;
      case 'linux-x86_64':
        assets.push(...findFiles(path.join(bundleDir, 'appimage'), /^mytips_.*_amd64\.AppImage(\.tar\.gz(\.sig)?)?$/));
        break;
      case 'windows-x86_64':
        assets.push(...findFiles(path.join(bundleDir, 'nsis'), /^mytips_.*_x64-setup(\.exe|\.nsis\.zip(\.sig)?)?$/));
        assets.push(...findFiles(path.join(bundleDir, 'msi'), /^mytips_.*_x64_en-US(\.msi|\.msi\.zip(\.sig)?)?$/));
        break;
    }
    return assets;
  };

  const allAssets = Object.keys(platforms).flatMap(getAssetPaths);
  const uniqueAssets = [...new Set(allAssets)];
  const manifestPath = path.relative(projectRoot, path.join(outputDir, 'latest.json'));

  const deployScript = `#!/bin/bash

# GitHub Release ÈÉ®ÁΩ≤ËÑöÊú¨
# ‰ΩøÁî® GitHub CLI ÂàõÂª∫ release Âπ∂‰∏ä‰º†Êñá‰ª∂

set -e

VERSION="${config.version}"
REPO="${config.repo}"
TAG="v$VERSION"
RELEASE_NOTES="${config.notes}"
PROJECT_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"

echo "Ê≠£Âú®ÂàõÂª∫ GitHub Release..."

# ÂàõÂª∫ release
gh release create "$TAG" \\
  --repo "$REPO" \\
  --title "v$VERSION" \\
  --notes "$RELEASE_NOTES" \\
  ${config.prerelease ? '--prerelease' : ''}

echo "Ê≠£Âú®‰∏ä‰º†ÊûÑÂª∫‰∫ßÁâ©..."

# List of assets to upload (paths are relative to project root)
ASSETS=(
${uniqueAssets.map(p => `  "${p.replace(/\\/g, '/')}"`).join('\n')}
)

for asset_relative_path in "\${ASSETS[@]}"; do
  asset_full_path="\$PROJECT_ROOT/\$asset_relative_path"
  if [ -f "\$asset_full_path" ]; then
    echo "Uploading \$asset_relative_path..."
    gh release upload "$TAG" --repo "$REPO" "\$asset_full_path"
  else
    echo "Warning: Asset not found, skipping: \$asset_full_path"
  fi
done

echo "Ê≠£Âú®‰∏ä‰º†Êõ¥Êñ∞Ê∏ÖÂçï..."

# ‰∏ä‰º†Êõ¥Êñ∞Ê∏ÖÂçï
manifest_full_path="\$PROJECT_ROOT/${manifestPath.replace(/\\/g, '/')}"
gh release upload "$TAG" \\
  --repo "$REPO" \\
  "\$manifest_full_path"

echo "‚úÖ GitHub Release ÂàõÂª∫ÂÆåÊàê!"
echo "üìç Release URL: https://github.com/$REPO/releases/tag/$TAG"

echo ""
echo "üì¶ Â∑≤‰∏ä‰º†ÁöÑÊñá‰ª∂:"
gh release view "$TAG" --repo "$REPO" --json assets --jq '.assets[].name' | sort
`

  const scriptPath = path.join(outputDir, 'deploy.sh')
  fs.writeFileSync(scriptPath, deployScript)
  
  // ‰ΩøËÑöÊú¨ÂèØÊâßË°å
  try {
    fs.chmodSync(scriptPath, '755')
  } catch (error) {
    console.warn('Ë≠¶Âëä: Êó†Ê≥ïËÆæÁΩÆÈÉ®ÁΩ≤ËÑöÊú¨ÁöÑÊâßË°åÊùÉÈôê')
  }
  
  console.log(`‚úÖ Â∑≤ÁîüÊàêÈÉ®ÁΩ≤ËÑöÊú¨: ${scriptPath}`)
}

// Ê£ÄÊü•ÊòØÂê¶‰∏∫Áõ¥Êé•ËøêË°åÔºàES Ê®°Âùó‰∏≠ÁöÑ require.main === module Êõø‰ª£ÊñπÊ°àÔºâ
if (import.meta.url === `file://${process.argv[1]}`) {
  main()
}

// ÂØºÂá∫ÂáΩÊï∞
export {
  generateUnifiedManifest,
  config
} 